[ 스프링 커리큐럼 ]

1부. 스프링 부트를 사용한 마이크로서비스 개발

1장. 마이크로서비스 소개
__기술 요구 사항
__저자의 마이크로서비스 경험
____독립 소프트웨어 컴포넌트의 장점
____독립 소프트웨어 컴포넌트의 문제
____마이크로서비스 입문
____샘플 마이크로서비스 환경
__마이크로서비스 정의
__마이크로서비스의 문제
__마이크로서비스 디자인 패턴
____서비스 검색
____에지 서버
____리액티브 마이크로서비스
____구성 중앙화
____로그 분석 중앙화
____분산 추적
____서킷 브레이커
____제어 루프
____모니터링 및 경고 중앙화
__필수 소프트웨어
__다른 주요 고려 사항
__요약

2장. 스프링 부트 소개
__기술 요구 사항
__스프링 부트
____설정보다 관례와 팻 JAR 파일
____스프링 부트 애플리케이션 설정에 대한 코드 예제
__스프링 웹플럭스
____REST 서비스 설정에 대한 코드 예제
__스프링 폭스
__스프링 데이터
____엔티티
____리포지토리
__스프링 클라우드 스트림
____스프링 클라우드 스트림을 사용한 메시지 송수신 예제
__도커
__요약
__질문

3장. 공조 마이크로서비스 집합 생성
__기술 요구 사항
__도구 설치
____소스 코드 다운로드
__마이크로서비스 환경 소개
____마이크로서비스가 처리하는 정보
____임시로 검색 서비스 대체
__골격 마이크로서비스 생성
____스프링 이니셜라이저로 골격 코드 생성
____그래들에 멀티 프로젝트 빌드 설정
__RESTful API 추가
____api 프로젝트와 util 프로젝트 추가
____API 구현
__복합 마이크로서비스 추가
____API 클래스
____속성
____통합 컴포넌트
____복합 API 구현
__예외 처리 추가
____전역 REST 컨트롤러 예외 핸들러
____API 구현의 예외 처리
____API 클라이언트의 예외 처리
__API 수동 테스트
____localhost의 조회 속도 문제 해결
__자동화된 마이크로서비스 테스트
__반자동화된 마이크로서비스 환경 테스트
____테스트 스크립트 실행
__요약
__질문

4장. 도커를 사용한 마이크로서비스 배포
__기술 요구 사항
__도커 소개
____첫 도커 명령 실행
__도커에서 자바를 실행할 때의 문제
____도커 없이 자바 커맨드 실행
____도커에서 자바 커맨드 실행
____자바 SE 9 도커 컨테이너의 문제
__도커로 단일 마이크로서비스 실행
____소스 코드 변경
____도커 이미지 빌드
____서비스 시작
____컨테이너를 분리 모드로 실행
__도커 컴포즈를 사용한 마이크로서비스 환경 관리
____소스 코드 변경
____마이크로서비스 환경 시작
__도커 컴포즈를 사용한 마이크로서비스 환경 테스트
____테스트 실행 문제 해결
__요약
__질문

5장. OpenAPI/스웨거를 사용한 API 문서화
__기술 요구 사항
__스프링 폭스 소개
__소스 코드 변경
____그래들 빌드 파일에 의존성 추가
____ProductCompositeServiceApplication에 구성과 API 정보 추가
____ProductCompositeService에 API 정보 추가
____속성 파일에 API 설명 추가
__마이크로서비스 환경 구축 및 시작
__스웨거 문서 사용법
__요약
__질문

6장. 영속성 추가
__기술 요구 사항
__진행 방향 확인
__핵심 마이크로서비스에 영속성 계층 추가
____의존성 추가
____엔티티 클래스를 사용해 데이터 저장
____스프링 데이터 리포지토리 정의
__영속성에 중점을 둔 자동 테스트 작성
__서비스 계층에서 영속성 계층 사용
____데이터베이스 연결 URL 기록
____새 API 추가
____영속성 계층 사용
____자바 빈 매퍼 선언
____서비스 테스트 업데이트
__복합 서비스 API 확장
____복합 서비스 API에 새 오퍼레이션 추가
____통합 계층에 메서드 추가
____새 복합 API 오퍼레이션 구현
____복합 서비스 테스트 업데이트
__도커 컴포즈 환경에 데이터베이스 추가
____도커 컴포즈 구성
____데이터베이스 연결 구성
____MongoDB 및 MySQL CLI 도구
__새 API 및 영속성 계층의 수동 테스트
__마이크로서비스 환경의 자동 테스트 업데이트
__요약
__질문

7장. 리액티브 마이크로서비스 개발
__기술 요구 사항
__논블로킹 동기 API와 이벤트 기반 비동기 서비스의 선택 기준
__스프링을 사용해 논블로킹 동기 REST API 개발
____스프링 리액터 소개
____스프링 데이터 MongoDB를 사용한 논블로킹 영속성
____핵심 서비스의 논블로킹 REST API
____복합 서비스의 논블로킹 REST API
__이벤트 기반 비동기 서비스 개발
____메시징 관련 문제를 처리하도록 스프링 클라우드 스트림 구성
____토픽 및 이벤트 정의
____그래들 빌드 파일 변경
____복합 서비스에서 이벤트 게시
____핵심 서비스에서 이벤트 소비
__리액티브 마이크로서비스 환경의 수동 테스트
____이벤트 저장
____상태 점검 API 추가
____파티션 없이 RabbitMQ 사용
____토픽당 2개의 파티션으로 RabbitMQ 사용
____토픽당 2개의 파티션으로 카프카 사용
__리액티브 마이크로서비스 환경의 자동 테스트
__요약
__질문

2부. 스프링 클라우드를 활용한 마이크로서비스 관리

8장. 스프링 클라우드 소개
__기술 요구 사항
__스프링 클라우드의 진화
__넷플릭스 유레카를 검색 서비스로 사용
__스프링 클라우드 게이트웨이를 에지 서버로 사용
__구성 중앙화를 위해 스프링 클라우드 컨피그 사용
__탄력성 향상을 위해 Resilience4j 사용
____Resilience4j를 사용한 서킷 브레이커 샘플
스프링 클라우드 슬루스와 집킨을 사용한 분산 추적
__요약
__질문

9장. 넷플릭스 유레카와 리본을 사용한 서비스 검색
__기술 요구 사항
__서비스 검색 소개
____DNS 기반 서비스 검색의 문제
____서비스 검색의 문제
____넷플릭스 유레카를 이용한 서비스 검색
__넷플릭스 유레카 서버 설정
__넷플릭스 유레카 서버에 마이크로서비스 연결
__개발 프로세스에서 사용할 구성 설정
____유레카 구성 매개 변수
____유레카 서버 구성
____유레카 서버에 연결할 클라이언트 구성
__검색 서비스 사용
____확장
____축소
____유레카 서버의 장애 상황 테스트
__요약
__질문

10장. 스프링 클라우드 게이트웨이를 에지 서버로 사용
__기술 요구 사항
__시스템 환경에 에지 서버 추가
__스프링 클라우드 게이트웨이 설정
____복합 상태 점검 추가
____스프링 클라우드 게이트웨이 구성
__에지 서버 테스트
____도커 엔진 외부로 공개되는 항목 확인
____라우팅 규칙 테스트
__요약
__질문

11장. API 접근 보안
__기술 요구 사항
__OAuth 2.0 및 OpenID Connect 소개
____OAuth 2.0 소개
____OpenID Connect 소개
__시스템 환경 보안
__시스템 환경에 권한 부여 서버 추가
__HTTPS를 사용한 외부 통신 보호
____런타임에 자체 서명 인증서 교체
__검색 서비스 접근 보안
____유레카 서버 변경
____유레카 클라이언트 변경
____보안 유레카 서버 테스트
__OAuth 2.0과 OpenID Connect를 사용한 API 접근 인증 및
__권한 부여
____에지 서버와 product-composite 서비스 변경
____product-composite 서비스 변경
____테스트 스크립트 변경
__로컬 권한 부여 서버를 사용한 테스트
____자동 테스트 빌드 및 실행
____접근 토큰 획득
____접근 토큰을 사용해 보안 API 호출
__Auth0를 OpenID Connect 공급자로 사용한 테스트
____Auth0 사용자 계정과 OAuth 2.0 클라이언트 설정
____Auth0를 OpenID 공급자로 사용하는 데 필요한 변경 사항 적용
____Auth0를 OpenID Connect 공급자로 사용해 테스트 스크립트 실행
____암호 승인 흐름을 사용해 접근 토큰 획득
____묵시적 승인 흐름을 사용해 접근 토큰 획득
____권한 코드 승인 흐름을 사용해 접근 토큰 획득
____Auth0 접근 토큰을 사용해 보호 API 호출
____사용자에 대한 추가 정보 획득
__요약
__질문

12장. 구성 중앙화
__기술 요구 사항
__스프링 클라우드 컨피그 서버 소개
____구성 저장소의 저장 유형 선택
____클라이언트가 먼저 접속할 서버 결정
____구성 보안
____구성 서버 API 소개
__구성 서버 설정
____에지 서버에 라우팅 규칙 설정
____도커 환경을 위한 구성 서버 설정
__구성 서버의 클라이언트 설정
____연결 정보 설정
____파티셔닝 구성을 도커 컴포즈 파일에서 구성 저장소로 이동
__구성 저장소 구조화
__스프링 클라우드 컨피그 서버 사용
____빌드 및 자동화 테스트 실행
____구성 서버 API로 구성 조회
____민감한 정보의 암호화 및 해독
__요약
__질문

13장. Resilience4j를 사용한 탄력성 개선
__기술 요구 사항
__Resilience4j의 서킷 브레이커와 재시도 메커니즘 소개
____서킷 브레이커 소개
____재시도 메커니즘 소개
__소스 코드에 서킷 브레이커 및 재시도 메커니즘 추가
____프로그래밍 방식으로 지연 및 무작위 오류 추가
____서킷 브레이커 추가
____서킷 브레이커 및 시간 초과 로직 추가
____재시도 메커니즘 추가
____자동 테스트 추가
__서킷 브레이커 및 재시도 메커니즘 테스트
____빌드 및 자동화 테스트 실행
____정상적인 요청만 유입될 때 서킷이 닫혀 있는지 확인
____문제가 발생했을 때 서킷이 열리는지 확인
____서킷 브레이커 다시 닫기
____무작위 오류로 재시도 메커니즘 테스트
__요약
__질문

14장. 분산 추적
__기술 요구 사항
__스프링 클라우드 슬루스와 집킨을 사용한 분산 추적
__소스 코드에 분산 추적 추가
____빌드 파일에 의존성 추가
____스프링 클라우드 슬루스 및 집킨에 대한 구성 추가
____도커 컴포즈 파일에 집킨 추가
__분산 추적 수행
____RabbitMQ를 대기열 관리자로 사용해 시스템 환경 시작
____정상적인 API 요청 전송
____비정상적인 API 요청 전송
____비동기 처리를 유발하는 API 요청 전송
____RabbitMQ를 통해 집킨으로 전달된 추적 정보 모니터링
____카프카를 메시지 브로커로 사용
__요약
__질문

3부. 쿠버네티스를 사용한 경량 마이크로서비스 개발

15장. 쿠버네티스 소개
__기술 요구 사항
__쿠버네티스 개념 소개
__쿠버네티스 API 객체 소개
__쿠버네티스 런타임 컴포넌트 소개
__미니큐브를 사용해 쿠버네티스 클러스터 생성
____미니큐브 프로필 사용
____쿠버네티스의 CLI 도구인 kubectl 사용
____kubectl 콘텍스트 사용
____쿠버네티스 클러스터 생성
__샘플 디플로이먼트 생성
__쿠버네티스 클러스터 관리
____쿠버네티스 클러스터 일시 정지 및 시작
____쿠버네티스 클러스터 종료
__요약
__질문


16장. 쿠버네티스에 마이크로서비스 배포
__기술 요구 사항
__넷플릭스 유레카를 쿠버네티스 서비스로 대체
__Kustomize 소개
____베이스 폴더에 공통 정의 설정
__개발 및 테스트 환경을 위한 쿠버네티스 배포
____도커 이미지 빌드
____쿠버네티스에 배포
____쿠버네티스 환경에 맞게 테스트 스크립트 수정
____디플로이먼트 테스트
__준비 및 상용 환경을 위한 쿠버네티스 배포
____소스 코드 수정
____쿠버네티스에 배포
__롤링 업그레이드 수행
____롤링 업그레이드 준비
____product 서비스를 v1에서 v2로 업그레이드
__실패한 디플로이먼트 롤백
____정리
__요약
__질문

17장. 쿠버네티스로 기존 인프라 대체
__기술 요구 사항
__스프링 클라우드 컨피그 서버 대체
____스프링 클라우드 컨피그 서버를 대체하기 위한 소스 코드 변경
__스프링 클라우드 게이트웨이 대체
____스프링 클라우드 게이트웨이를 대체하기 위한 소스 코드 변경
__쿠버네티스 컨피그 맵, 시크릿, 인그레스 리소스를 사용한 테스트
____배포 스크립트 분석
____배포 및 테스트 커맨드 실행
__인증서 프로비저닝 자동화
____Cert Manager 배포 및 Let’s Encrypt 발급자 정의
____ngrok으로 HTTP 터널 생성
____Cert Manager와 Let’s Encrypt를 사용한 인증서 프로비저닝
____정리
__쿠버네티스 없이도 마이크로서비스가 작동하는지 확인
____도커 컴포즈 소스 코드 수정
____도커 컴포즈로 테스트
__요약
__질문

18장. 서비스 메시를 사용해 관찰 가능성 및 관리 편의성 개선
__기술 요구 사항
__이스티오를 이용한 서비스 메시 소개
____기존 마이크로서비스에 이스티오 프록시 삽입
____이스티오의 API 객체 소개
____이스티오의 런타임 컴포넌트 소개
____마이크로서비스 환경의 변경 사항
__쿠버네티스 클러스터에 이스티오 배포
____이스티오 서비스에 대한 접근 설정
__서비스 메시 생성
____소스 코드 변경
____커맨드를 실행해 서비스 메시 생성
__서비스 메시 관찰
__서비스 메시 보안
____HTTPS와 인증서로 외부 엔드포인트 보호
____OAuth 2.0/OIDC 접근 토큰을 사용한 외부 요청 인증
____상호 인증을 사용한 내부 통신 보호
__서비스 메시의 탄력성 확보
____결함을 삽입해 탄력성 테스트
____지연을 삽입해 탄력성 테스트
__비가동 시간 없이 배포 수행
____소스 코드 변경
____v1 및 v2 버전의 마이크로서비스 배포
____모든 트래픽이 v1 버전의 마이크로서비스로 전달되는지 확인
____카나리아 테스트 실행
____블루/그린 테스트 실행
__도커 컴포즈로 테스트 실행
__요약
__질문

19장. EFK 스택을 사용한 로깅 중앙화
__기술 요구 사항
__플루언티드 구성
____플루언티드 소개
____플루언티드 구성
__쿠버네티스에 EFK 스택 배포
____마이크로서비스 빌드 및 배포
____일래스틱서치와 키바나 배포
____플루언티드 배포
__EFK 스택 실습
____키바나 초기화
____로그 레코드 분석
____마이크로서비스의 로그 레코드 검색
____근본 원인 분석 수행
__요약
__질문

20장. 마이크로서비스 모니터링
__기술 요구 사항
__프로메테우스와 그라파나를 사용한 성능 모니터링
__애플리케이션 메트릭 수집을 위한 소스 코드 변경
__마이크로서비스 빌드 및 배포
__그라파나 대시보드를 사용한 마이크로서비스 모니터링
____테스트용 로컬 메일 서버 설치
____부하 테스트 실행
____키알리의 그라파나 대시보드
____기존 그라파나 대시보드 가져오기
____사용자 정의 그라파나 대시보드 개발
__그라파나 경고 설정
____메일 기반 알림 채널 정의
____서킷 브레이커에 경고 설정
____서킷 브레이커 경고 테스트
__요약
__질문